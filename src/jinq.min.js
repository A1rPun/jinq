!function (a, b) { if ("undefined" != typeof module) module.exports = b(); else if ("function" == typeof define && "object" == typeof define.amd) define(b); else { var c = this[a]; this[a] = b(), c && (this[a].noConflict = c) } }("jinq", function () { function a(a, b) { a ? (this.list = a.list, this.queue = a.queue.slice(), b && this.queue.push(b)) : (this.list = [], this.queue = []) } a.prototype = { __resolveQueue: function () { this.list = this.list.slice(); for (var a = 0, b = this.queue.length; a < b; a++) { var c = this.queue[a]; c[0].apply(this, c[1]) } }, __makeOrderBy: function (a, b) { function c(a) { return b ? function (b, c) { return b[a] > c[a] ? -1 : c[a] > b[a] ? 1 : 0 } : function (b, c) { return b[a] > c[a] ? 1 : c[a] > b[a] ? -1 : 0 } } for (var d = a.length; d--;) { var e = a[d]; "function" != typeof e && (a[d] = c(e)) } return function (b, c) { for (var f, d = 0, e = a.length; d < e; d++) if (f = a[d](b, c)) return f; return 0 } }, aggregate: function (a, b) { var c = this; c.__resolveQueue(); var d = 0 === b ? 0 : b || null, e = 0, f = c.list.length; if (0 == f) return d; for (null === d && (d = c.list[0], e = 1), f = c.list.length; e < f; e++) { var g = c.list[e]; d = a.call(c.list, d, g, e) } return d }, all: function (a) { this.__resolveQueue(); for (var b = 0, c = this.list.length; b < c; b++) if (!a.call(this.list, this.list[b], b)) return !1; return !0 }, any: function (a) { return !!this.first(a) }, average: function () { return this.sum() / this.list.length }, contains: function (a) { return this.__resolveQueue(), this.list.indexOf(a) !== -1 }, count: function (a) { return this.toArray(a).length }, elementAt: function (a) { var b = this.toArray(); return a < b.length ? b[a] : null }, first: function (a) { var b = this.toArray(a), c = b.length; return c ? b[0] : null }, last: function (a) { var b = this.toArray(a), c = b.length; return c ? b[b.length - 1] : null }, max: function () { return this.__resolveQueue(), Math.max.apply(null, this.list) }, min: function () { return this.__resolveQueue(), Math.min.apply(null, this.list) }, sum: function () { this.__resolveQueue(); for (var a = 0, b = this.list; b--;) a += this.list[b]; return a }, toArray: function (a) { return a && this.where(a), this.__resolveQueue(), this.list } }; var b = { concat: function (a) { var b = this; return b.list = b.list.concat.apply(b.list, a), b }, distinct: function (a) { for (var b = this, c = [], d = {}, e = 0, f = b.list.length; e < f; e++) { var g = b.list[e], h = a ? a.call(b.list, g, e) : g; d[h] || (d[h] = !0, c.push(g)) } return b.list = c, b }, except: function (a, b) { for (var h, i, c = this, d = [], e = {}, f = 0, g = a.length; f < g; f++) h = a[f], i = b ? b.call(a, h, f) : h, e[i] = !0; for (f = 0, g = c.list.length; f < g; f++) h = c.list[f], i = b ? b.call(c.list, h, f) : h, e[i] || d.push(h); return c.list = d, c }, groupBy: function (a) { for (var b = this, c = [], d = {}, e = 0, f = b.list.length; e < f; e++) { var g = b.list[e], h = a.call(b.list, g, e); if (d[h]) d[h].push(g); else { var i = [g]; d[h] = i, c.push({ key: h, value: i }) } } return b.list = c, b }, intersect: function (a, b) { for (var h, i, c = this, d = [], e = {}, f = 0, g = a.length; f < g; f++) h = a[f], i = b ? b.call(a, h, f) : h, e[i] = !0; for (f = 0, g = c.list.length; f < g; f++) h = c.list[f], i = b ? b.call(c.list, h, f) : h, e[i] && d.push(h); return c.list = d, c }, join: function (a, b, c, d) { for (var j, k, e = this, f = [], g = {}, h = 0, i = a.length; h < i; h++) j = a[h], k = j[c], k && (g[k] = j); for (h = 0, i = e.list.length; h < i; h++) if (j = e.list[h], k = j[b]) { var l = g[k]; if (l) { if (d) j = d.call(e.list, j, g[k], h); else for (var m in l) j[m] || (j[m] = l[m]); f.push(j) } } return e.list = f, e }, orderBy: function (a) { return this.list.sort(a ? this.__makeOrderBy(arguments) : a), this }, orderByDescending: function (a) { return this.list.sort(a ? this.__makeOrderBy(arguments, !0) : function (a, b) { return a > b ? -1 : b > a ? 1 : 0 }), this }, reverse: function () { for (var a = this, b = [], c = a.list.length; c--;) b.push(a.list[c]); return a.list = b, a }, select: function (a) { for (var b = this, c = [], d = 0, e = b.list.length; d < e; d++) { var f = b.list[d], g = a.call(b.list, f, d); c.push(g) } return b.list = c, b }, selectMany: function (a) { for (var b = this, c = [], d = 0, e = b.list.length; d < e; d++) { var f = b.list[d], g = a.call(b.list, f, d); c.concat(g) } return b.list = c, b }, shuffle: function () { for (var b, c, a = this.list.length; a--;) b = Math.floor(Math.random() * (a + 1)), c = this.list[a], this.list[a] = this.list[b], this.list[b] = c; return this }, skip: function (a) { return this.list = this.list.slice(a), this }, take: function (a) { return this.list = this.list.slice(0, a), this }, union: function (a, b) { for (var h, i, c = this, d = [], e = {}, f = 0, g = c.list.length; f < g; f++) h = c.list[f], i = b ? b.call(c.list, h, f) : h, e[i] || (e[i] = !0, d.push(h)); for (f = 0, g = a.length; f < g; f++) h = a[f], i = b ? b.call(a, h, f) : h, e[i] || (e[i] = !0, d.push(h)); return c.list = d, c }, where: function (a) { for (var b = this, c = [], d = 0, e = b.list.length; d < e; d++) { var f = b.list[d]; a.call(b.list, f, d) && c.push(f) } return b.list = c, b }, zip: function (a, b) { for (var c = this, d = [], e = c.list.length, f = a.length, g = e < f ? e : f, h = 0; h < g; h++) { var i = c.list[h], j = a[h], k = b.call(c.list, i, j, h); d.push(k) } return c.list = d, c } }; for (var c in b) a.prototype[c] = function (b) { return function () { return this.queue.push(), new a(this, [b, arguments]) } }(b[c]); var d = function (b) { var c = new a; return c.list = b, c }; return d.empty = function () { return new a }, d.range = function (a, b) { for (var c = [], e = a + b; a < e; a++) c.push(a); return d(c) }, d.repeat = function (a, b) { for (var c = [], e = 0; e < b; e++) c.push(a); return d(c) }, d });