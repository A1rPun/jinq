// TODO: Fix any's with generics
declare class Enumerable {
  constructor(iterator: Iterable<any>);
  aggregate(seed: any, accumulator: (result: any, element: any, index: number) => any, resultSelector: (element: any) => any): any;
  all(predicate: (element: any) => boolean): boolean;
  any(predicate: (element: any) => boolean): boolean;
  append(...elements: any): Enumerable;
  asEnumerable(): Enumerable;
  average(selector: (element: any) => number): any;
  chunk(size: number): Enumerable;
  concat(list: Iterable<any>): Enumerable;
  contains(element: any, comparer: (value: any, element: any) => any): boolean;
  count(predicate: (element: any) => boolean): number;
  defaultIfEmpty(defaultValue: any): Enumerable;
  distinct(): Enumerable;
  distinctBy(keySelector: (element: any) => string): Enumerable;
  elementAt(atIndex: number): any;
  elementAtOrDefault(atIndex: number): any;
  static empty(): Enumerable;
  except(list: Iterable<any>): Enumerable;
  exceptBy(list: Iterable<any>, keySelector: (element: any) => string): Enumerable;
  first(predicate: (element: any) => boolean): any;
  firstOrDefault(predicate: (element: any) => boolean, defaultValue: any): any;
  static from<T>(iterator: Iterable<T>): Enumerable;
  groupBy(keySelector: (element: any) => string, elementSelector: (element: any) => any, resultSelector: (element: any) => any): Enumerable;
  groupJoin(list: Iterable<any>, outerKeySelector: (element: any) => string, innerKeySelector: (element: any) => string, resultSelector: (element: any) => any): Enumerable;
  intersect(list: Iterable<any>): Enumerable;
  intersectBy(list: Iterable<any>, keySelector: (element: any) => string): Enumerable;
  join(list: Iterable<any>, outerKeySelector: (element: any) => string, innerKeySelector: (element: any) => string, resultSelector: (element: any) => any): Enumerable;
  last(predicate: (element: any) => boolean): any;
  lastOrDefault(predicate: (element: any) => boolean, defaultValue: any): any;
  longCount(predicate: (element: any) => boolean): BigInt;
  max(): number;
  maxBy(selector: (element: any) => number): number;
  min(): number;
  minBy(selector: (element: any) => number): number;
  ofType(type: string): Enumerable;
  orderBy(keySelector: (element: any) => string): Enumerable;
  orderByDescending(keySelector: (element: any) => string): Enumerable;
  prepend(...elements: any): Enumerable;
  static range(start: number, count: number): Enumerable;
  static repeat(start: number, count: number): Enumerable;
  reverse(): Enumerable;
  select(selector: (element: any) => any): Enumerable;
  selectMany(collectionSelector: (element: any) => any, resultSelector: (element: any) => any): Enumerable;
  sequenceEqual(list: Iterable<any>, comparer: (value: any, element: any) => any): boolean;
  single(predicate: (element: any) => boolean): any;
  singleOrDefault(predicate: (element: any) => boolean, defaultValue: any): any;
  skip(skip: number): Enumerable;
  skipLast(count: number): Enumerable;
  skipWhile(predicate: (element: any) => boolean): Enumerable;
  sum(selector: (element: any) => number): number;
  take(take: number): Enumerable;
  takeLast(count: number): Enumerable;
  takeWhile(predicate: (element: any) => boolean): Enumerable;
  toArray(): Array<any>;
  toDictionary(keySelector: (element: any) => string, elementSelector: (element: any) => any): Map<string, any>;
  toHashSet(): Set<any>;
  toList(): Array<any>;
  toLookup(keySelector: (element: any) => string, elementSelector: (element: any) => any): Map<string, any>;
  tryGetNonEnumeratedCount(): number | undefined;
  union(list: Iterable<any>, comparer: (value: any, element: any) => any): Enumerable;
  unionBy(list: Iterable<any>, keySelector: (element: any) => string, comparer: (value: any, element: any) => any): Enumerable;
  where(predicate: (element: any) => boolean): Enumerable;
  zip(list: Iterable<any>, zipFn: (a: any, b: any) => any): Enumerable;
}

export { Enumerable as jinq };
